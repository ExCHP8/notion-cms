{"version":3,"file":"index.js","sources":["../src/notion-cms.ts"],"sourcesContent":["import { Client, isFullPage } from \"@notionhq/client\"\nimport {PageObjectResponse, GetPageResponse} from '@notionhq/client/build/src/api-endpoints'\nimport { NotionBlocksHtmlParser } from '@notion-stuff/blocks-html-parser'\nimport {Blocks} from '@notion-stuff/v4-types'\nimport type { Cover, CMS, Page, PageContent, RouteObject, Transient, PageObjectTitle, PageObjectRelation, PageObjectUser, PageMultiSelect, pendingEntry} from \"./types\"\nimport _ from 'lodash'\nimport fs from 'fs'\nimport {dirname} from 'path'\n\nfunction writeFile(path: string, contents: string) {\n  fs.mkdirSync(dirname(path), { recursive: true})\n  fs.writeFileSync(path, contents);\n}\n\nconst COVER_IMAGE_REGEX = /<figure notion-figure>[\\s\\S]+<img[^>]*src=['|\"](https?:\\/\\/[^'|\"]+)(?:['|\"])/\n\n\nObject.defineProperty(String.prototype, \"slug\", {\n  get: function() {\n    return _.kebabCase(this)\n  }\n})\n\nObject.defineProperty(String.prototype, \"route\", {\n  get: function(separator = \"/\") {\n    return this.padStart(this.length + 1, separator)\n  }\n})\n\ninterface Options {\n  databaseId: string,\n  notionAPIKey: string,\n  debug?: boolean,\n  rootUrl?: string | URL | undefined // Used to generate full path links\n}\n\nexport default class NotionCMS {\n  cms: CMS\n  cmsId: string\n  notionClient: Client\n  parser: NotionBlocksHtmlParser\n  pendingEntries: Set<pendingEntry>\n  pageRetrievalCache: Record<string, GetPageResponse>\n  debug: boolean | undefined\n\n  constructor({databaseId, notionAPIKey, debug, rootUrl}: Options = {databaseId : '', notionAPIKey: '', debug: false, rootUrl: ''}) {\n    this.cms = {\n      metadata: {\n        databaseId,\n        rootUrl: rootUrl ? new URL(rootUrl) : ''\n      },\n      routes: [],\n      tags: [],\n      tagGroups: {},\n      transient: {},\n      siteData: {}\n    }\n    this.cmsId = databaseId\n    this.notionClient = new Client({\n      auth: notionAPIKey\n    })\n    this.parser = NotionBlocksHtmlParser.getInstance()\n    this.pendingEntries = new Set<pendingEntry>()\n    this.pageRetrievalCache = {}\n    this.debug = debug\n  }\n\n  get data() {\n    if (_.isEmpty(this.cms.siteData)) return\n    return this.cms.siteData\n  }\n\n  get routes() {\n    if (_.isEmpty(this.cms.siteData)) return\n    if (this.toplevelDirectories) {\n      this.cms.routes = []\n      this.toplevelDirectories.forEach(tld => {\n        this.cms.routes.push(this._genRoutes(tld))\n      })\n      return this.cms.routes = this.cms.routes.flat()\n    }\n  }\n\n  get toplevelDirectories() {\n    if (_.isEmpty(this.cms.siteData)) return\n    return Object.entries(this.cms.siteData)\n  }\n\n  _genRoutes(directory: RouteObject): Array<string> {\n    const results = []\n    const routePart = directory[0]\n    const routeChildren = _(directory[1]).pickBy((value, key) => _.startsWith(key, '/')).entries().value()\n    if (!routeChildren.length) return [routePart]\n    routeChildren.forEach(childDirectory => {\n      const childRes = this._genRoutes(childDirectory)\n      if (childRes.length) {\n        childRes.forEach(res => results.push(routePart + res))\n      } else {\n        results.push(routePart + childRes)\n      }\n    })\n    results.push(routePart)\n    return results\n  }\n\n  _clearPageRetrievalCache(): void {\n    this.pageRetrievalCache = {}\n  }\n\n  _isTopLevelDir (response: PageObjectResponse): boolean {\n    const parentPage = response?.properties['parent-page'] as PageObjectRelation \n    return _.isEmpty(parentPage.relation)\n  }\n  \n  _getBlockName(response: PageObjectResponse): string {\n    const nameProp = response?.properties.name as PageObjectTitle \n    return nameProp.title[0]?.plain_text\n  }\n\n  _extractTags(response: PageObjectResponse): Array<string> {\n    const tagProp = response?.properties?.Tags as PageMultiSelect\n    return tagProp.multi_select.map(multiselect => multiselect.name)\n  }\n\n  _assignTagGroup(tag: string, route: string, cms: CMS): void {\n    if (!cms.tagGroups[tag]) cms.tagGroups[tag] = []\n    cms.tagGroups[tag].push(route)\n  }\n\n  _findByKey(object: Record<string, Page>, key: string): Record<string, Page> | undefined {\n    let value;\n    Object.keys(object).some((k: string) => {\n      if (k === key) {\n        value = object[k];\n        return true;\n      }\n      if (object[k] && typeof object[k] === 'object') {\n        value = this._findByKey(object[k] as Record<string, Page>, key);\n        return value !== undefined;\n      }\n    });\n    return value;\n  }\n\n  _getCoverImage(page: PageObjectResponse, source: string): URL {\n    const pageCoverProp = (page as PageObjectResponse)?.cover as Cover\n    let coverImage;\n    if (pageCoverProp && 'external' in pageCoverProp) {\n      coverImage = pageCoverProp?.external?.url\n    } else if (pageCoverProp?.file){\n      coverImage = pageCoverProp?.file.url\n    } else {\n     coverImage = source.match(COVER_IMAGE_REGEX)?.[1]\n    }\n    return coverImage\n  }\n\n  async _pullPageContent(id: string, cms: CMS): Promise<PageContent> {\n    let page\n    const tags = [] as Array<string>\n    page = await this._retrievePage(id)\n  \n    const pageContent = await this.notionClient.blocks.children.list({\n      block_id: id,\n      page_size: 50,\n    })\n    const name = this._getBlockName(page as PageObjectResponse).slug\n    const parsed = this.parser.parse(pageContent.results as Blocks)\n\n    // Fall back to the first image in the page if one exists.\n    if (isFullPage(page as PageObjectResponse)) {\n      const coverImage = this._getCoverImage(page as PageObjectResponse, parsed)\n      const extractedTags = this._extractTags(page as PageObjectResponse)\n      extractedTags.forEach(tag => {\n        tags.push(tag)\n        if (!_.includes(cms.tags, tag)) cms.tags.push(tag)\n        this._assignTagGroup(tag, name.route, cms)\n      })\n      return {\n        name,\n        tags,\n        coverImage,\n        content: parsed\n      }\n    } else return {\n      name: '',\n      tags: [],\n      coverImage: new URL(''),\n      content: ''\n    }\n  }\n\n  _findInPending(entry: Transient) {\n    let match\n    this.pendingEntries.forEach(pendingEntry => {\n      if (entry === pendingEntry.entry) {\n        match = pendingEntry\n      }\n    })\n    return match\n  }\n\n  async _retrievePage(id: string): Promise<GetPageResponse> {\n    let parentPage = this.pageRetrievalCache[id]\n    // Check cache before making this call.\n    if (!parentPage) {\n      parentPage = await this.notionClient.pages.retrieve({ page_id: id })\n      this.pageRetrievalCache[id] = parentPage\n    }\n    return parentPage\n  }\n\n  async _addPage(entry: Transient, id:string, siteData: CMS['siteData']): Promise<void> {\n    let page, name, parentPage, parentName, updateObject;\n    const parentId = entry.parentPage \n\n    if (parentId){\n      parentPage = await this._retrievePage(parentId)\n    }\n    page = await this._retrievePage(id)\n    if (page && isFullPage(page)) {\n      name = this._getBlockName(page).slug.route\n      const authorProp = page.properties?.Author as PageObjectUser\n      const authorIds = authorProp['people']\n      entry['authorIds'] = authorIds.map(authorId => authorId.id)\n      entry['name'] = name\n      if (parentPage && isFullPage(parentPage)) {\n        parentName = this._getBlockName(parentPage).slug.route\n        updateObject = this._findByKey(siteData, parentName)\n      } else {\n        updateObject = siteData\n      }\n    }\n\n    if (updateObject && name) {\n      if (!updateObject[name]) updateObject[name] = {} as Page\n      const match = this._findInPending(entry)\n      if (match) this.pendingEntries.delete(match)\n    } else {\n      let shouldAdd = true\n      for (const pendingEntry of this.pendingEntries) {\n        if (_.isEqual(entry, pendingEntry.entry)) {\n          shouldAdd = false; break;\n        };\n      }\n      if (shouldAdd) {\n        this.pendingEntries.add({\n          id,\n          entry\n        })\n      }\n    }\n  }\n\n  async _getAuthorData(authorIds: Array<string>): Promise<Array<string>> {\n   let authors;\n    if (authorIds?.length) {\n      authors = await Promise.all(\n        authorIds.map(async (authorId: string) => {\n        return await this.notionClient.users.retrieve({ user_id: authorId })\n        })\n      ).then(res => {\n        if (res?.length) {\n          return res.map(author => author.name as string)\n        }\n      })\n      return authors || []\n    }\n    return []\n  }\n\n  async _getPageContent(state: CMS): Promise<CMS> {\n    let stateWithContent = _.cloneDeep(state)\n    if (!stateWithContent.transient) return stateWithContent\n    for await (const [idx, entry] of Object.entries(stateWithContent.transient)) {\n      let updateObject = this._findByKey(stateWithContent.siteData, entry.name) as Page\n      const content = await this._pullPageContent(idx, stateWithContent)\n      updateObject.name = content.name\n      updateObject.tags = content.tags\n      updateObject.coverImage = content.coverImage\n      updateObject.content = content.content\n    }\n    return stateWithContent\n  }\n\n  async _getAuthors(state: CMS): Promise<CMS> {\n    let stateWithAuthors = _.cloneDeep(state)\n    if (!stateWithAuthors.transient) return stateWithAuthors\n    for await (const [idx, entry] of Object.entries(stateWithAuthors.transient)) {\n      const updateObject = this._findByKey(stateWithAuthors.siteData, entry.name) as Page\n      updateObject.authors = await this._getAuthorData(entry.authorIds as Array<string>)\n    }\n    return stateWithAuthors\n  }\n\n  async _getPages(state: CMS): Promise<CMS> {\n    let stateWithPages = _.cloneDeep(state)\n    if (!stateWithPages.transient) return stateWithPages\n    for await (const [id, entry] of Object.entries(stateWithPages.transient)) {\n      await this._addPage(entry, id, stateWithPages.siteData)          \n    }\n    \n    while (this.pendingEntries.size) {\n      for await (const pendingEntry of this.pendingEntries) {\n        await this._addPage(pendingEntry.entry, pendingEntry.id, stateWithPages.siteData)\n      }\n    }  \n\n    return stateWithPages\n  }\n\n  async _getDb(state: CMS): Promise<CMS> {\n     let stateWithDb = _.cloneDeep(state)\n    if (!stateWithDb.transient) return stateWithDb\n     const db = await this.notionClient.databases.query({\n      database_id: state.metadata.databaseId,\n    });\n     for await (const entry of db.results as PageObjectResponse[]) {\n      // Fetch page: parent-page relationship here and store in transient object.\n      let transient = stateWithDb.transient[entry.id] = {name: '', parentPage: '', authorIds: undefined}\n      const parentPage = entry.properties['parent-page'] as PageObjectRelation\n      if (parentPage) transient['parentPage'] = parentPage.relation[0]?.id\n    }\n    return stateWithDb\n  }\n\n  async fetch(): Promise<CMS> {\n    // For now clear the cache anytime we re-run the fetch. In the future we want to make the cache clearing dynamically based on \n    // an AgencyKit API flag.\n    this._clearPageRetrievalCache()\n       \n    this.cms =\n      await this._getPageContent(\n        await this._getAuthors(\n          await this._getPages(\n            await this._getDb(this.cms)\n          )\n        )\n      )\n\n    delete this.cms['transient']\n\n    void this.routes\n    if (this.debug) writeFile('debug/site-data.json', JSON.stringify(this.cms))\n    return this.cms\n  }\n\n  getTaggedCollection(tags: string | Array<string>): Array<Record<string, Page> | undefined> {\n    if (!_.isArray(tags)) tags = [tags]\n    const taggedPages = []\n    for (const tag of tags) {\n      taggedPages.push(...this.cms.tagGroups[tag])\n    }\n    return _(taggedPages).map(page => this._findByKey(this.cms.siteData, page)).uniq().value()\n  }\n}\n"],"names":["COVER_IMAGE_REGEX","Object","defineProperty","String","prototype","get","_","kebabCase","this","separator","padStart","length","NotionCMS","cms","cmsId","notionClient","parser","pendingEntries","pageRetrievalCache","debug","constructor","databaseId","notionAPIKey","rootUrl","metadata","URL","routes","tags","tagGroups","transient","siteData","Client","auth","NotionBlocksHtmlParser","getInstance","Set","data","isEmpty","toplevelDirectories","forEach","tld","push","_genRoutes","flat","entries","directory","results","routePart","routeChildren","pickBy","value","key","startsWith","childDirectory","childRes","res","_clearPageRetrievalCache","_isTopLevelDir","response","parentPage","properties","relation","_getBlockName","nameProp","name","title","plain_text","_extractTags","tagProp","Tags","multi_select","map","multiselect","_assignTagGroup","tag","route","_findByKey","object","keys","some","k","_getCoverImage","page","source","pageCoverProp","cover","coverImage","external","url","file","match","async","id","_retrievePage","pageContent","blocks","children","list","block_id","page_size","slug","parsed","parse","isFullPage","includes","content","_findInPending","entry","pendingEntry","pages","retrieve","page_id","parentName","updateObject","parentId","authorProp","Author","authorIds","authorId","delete","shouldAdd","isEqual","add","authors","Promise","all","users","user_id","then","author","state","stateWithContent","cloneDeep","idx","_pullPageContent","stateWithAuthors","_getAuthorData","stateWithPages","_addPage","size","stateWithDb","db","databases","query","database_id","path","contents","_getPageContent","_getAuthors","_getPages","_getDb","JSON","stringify","fs","mkdirSync","dirname","recursive","writeFileSync","getTaggedCollection","isArray","taggedPages","uniq"],"mappings":"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"}