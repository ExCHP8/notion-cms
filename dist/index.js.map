{"version":3,"file":"index.js","sources":["../src/notion-cms.ts"],"sourcesContent":["import { Client, isFullPage } from \"@notionhq/client\"\nimport {PageObjectResponse,\n  DatabaseObjectResponse, \n  TextRichTextItemResponse, UserObjectResponse} from '@notionhq/client/build/src/api-endpoints'\nimport { NotionBlocksHtmlParser } from '@notion-stuff/blocks-html-parser'\nimport {Blocks} from '@notion-stuff/v4-types'\nimport type { PageEntry, CMS, PageContent, RouteObject, Cover, PageObjectTitle, PageObjectRelation, PageObjectUser} from \"./types\"\nimport _ from 'lodash'\nimport fs from 'fs'\n\nconst COVER_IMAGE_REGEX = /<figure notion-figure>[\\s\\S]+<img[^>]*src=['|\"](https?:\\/\\/[^'|\"]+)(?:['|\"])/\n\n\nObject.defineProperty(String.prototype, \"slug\", {\n  get: function() {\n    return _.kebabCase(this)\n  }\n})\n\nObject.defineProperty(String.prototype, \"route\", {\n  get: function(separator = \"/\") {\n    return this.padStart(this.length + 1, separator)\n  }\n})\n\nexport default class NotionCMS {\n  cms: CMS\n  cmsId: string\n  notionClient: Client\n  parser: NotionBlocksHtmlParser\n\n  constructor(databaseID: string, notionAPIKey: string) {\n    this.cms = {\n      metadata: {},\n      routes: [],\n      siteData: {}\n    }\n    this.cmsId = databaseID\n    this.notionClient = new Client({\n      auth: notionAPIKey\n    })\n    this.parser = NotionBlocksHtmlParser.getInstance()\n  }\n\n  get routes() {\n    if (_.isEmpty(this.cms.siteData)) return\n    console.log(this.toplevelDirectories)\n    if (this.toplevelDirectories) {\n      this.toplevelDirectories.forEach(tld => {\n        this.cms.routes.push(this._genRoutes(tld))\n      })\n      console.log('got it odne', this.cms.routes)\n      this.cms.routes = this.cms.routes.flat()\n    }\n  }\n\n  get toplevelDirectories() {\n    if (_.isEmpty(this.cms.siteData)) return\n    return Object.entries(this.cms.siteData)\n  }\n\n  _genRoutes(directory: RouteObject): Array<string> {\n    const results = []\n    const routePart = directory[0]\n    const routeChildren = _(directory[1]).pickBy((value, key) => _.startsWith(key, '/')).entries().value()\n    if (!routeChildren.length) return [routePart]\n    routeChildren.forEach(childDirectory => {\n      const childRes = this._genRoutes(childDirectory)\n      if (childRes.length) {\n        childRes.forEach(res => results.push(routePart + res))\n      } else {\n        results.push(routePart + childRes)\n      }\n    })\n    results.push(routePart)\n    return results\n  }\n\n  _isTopLevelDir (response: PageObjectResponse): boolean {\n    const parentPage = response?.properties['parent-page'] as PageObjectRelation \n    return _.isEmpty(parentPage.relation)\n  }\n  \n  _getBlockName(response: PageObjectResponse): string {\n    const nameProp = response?.properties.name as PageObjectTitle \n    return nameProp.title[0]?.plain_text\n  }\n\n  async _getAuthorData(page: PageObjectResponse): Promise<Array<string>> {\n    const authorProp = page.properties?.Author as PageObjectUser\n    const authorIds = authorProp['people']\n    let authors;\n    if (authorIds?.length) {\n      authors = await Promise.all(\n        authorIds.map(async (author: UserObjectResponse) => await this.notionClient.users.retrieve({ user_id: author.id }))\n      ).then(res => {\n        if (res?.length) {\n          return res.map(author => author.name as string)\n        }\n      })\n      return authors || []\n    }\n    return []\n  }\n\n  _findKey(object: Record<string, object>, key: string): Record<string, object> | undefined {\n    let value;\n    Object.keys(object).some((k: string) => {\n      if (k === key) {\n        value = object[k];\n        return true;\n      }\n      if (object[k] && typeof object[k] === 'object') {\n        value = this._findKey(object[k] as Record<string, object>, key);\n        return value !== undefined;\n      }\n    });\n    return value;\n  }\n\n  async _getPageContent(subPage: PageObjectResponse | PageObjectRelation): Promise<PageContent> {\n    let page;\n    if ((subPage as PageObjectResponse)?.object === 'page') {\n      page = subPage\n    } else {\n      page = await this.notionClient.pages.retrieve({\n        page_id: subPage.id\n      })\n    }\n  \n    const pageContent = await this.notionClient.blocks.children.list({\n      block_id: subPage.id,\n      page_size: 50,\n    })\n  \n    const parsed = this.parser.parse(pageContent.results as Blocks)\n  \n    // Fall back to the first image in the page if one exists.\n    if (isFullPage(page as PageObjectResponse)) {\n      const pageCoverProp = (page as PageObjectResponse)?.cover as Cover\n      let coverImage;\n      if (pageCoverProp && 'external' in pageCoverProp) {\n        coverImage = pageCoverProp?.external?.url\n      } else if (pageCoverProp?.file){\n        coverImage = pageCoverProp?.file.url \n      } else {\n       coverImage = parsed.match(COVER_IMAGE_REGEX)?.[1]\n      }\n  \n      return {\n        name: this._getBlockName(page as PageObjectResponse).slug,\n        authors: await this._getAuthorData(page as PageObjectResponse),\n        coverImage,\n        content: parsed\n      }\n    } else return {\n      name: '',\n      authors: [],\n      coverImage: new URL(''),\n      content: ''\n    }\n  }\n\n  async fetchCms(): Promise<CMS> {\n    const db = await this.notionClient.databases.query({\n      database_id: this.cmsId,\n    });\n  \n    const pendingEntries = new Set<PageEntry>()\n  \n    const findInPending = (entry: PageObjectResponse, pendingEntries: Set<PageEntry>) => {\n      let match\n      pendingEntries.forEach(pendingEntry => {\n        if (entry === pendingEntry.entry) {\n          match = pendingEntry\n        }\n      })\n      return match\n    }\n  \n    const addSubPage = async (entry: PageObjectResponse): Promise<void> => {\n      const parentPageProp = entry.properties['parent-page'] as PageObjectRelation\n      const parent = parentPageProp.relation[0]\n      // how to avoid this async call? It causes the process to take quite a long time.\n      const parentPage = await this.notionClient.pages.retrieve({ page_id: parent.id })\n      if (isFullPage(parentPage)) {\n        const parentName = this._getBlockName(parentPage).slug.route\n        const updateKey = this._findKey(this.cms.siteData, parentName)\n    \n        if (updateKey) {\n          const content = await this._getPageContent(entry)\n          if (!updateKey[content.name.route]) updateKey[content.name.route] = content\n    \n          const match = findInPending(entry, pendingEntries)\n          if (match) pendingEntries.delete(match)\n        } else {\n          let shouldAdd = true\n          for (const pendingEntry of pendingEntries) {\n            if (_.isEqual(entry, pendingEntry.entry)) {\n              shouldAdd = false; break;\n            };\n          }\n          if (shouldAdd) {\n            pendingEntries.add({\n              parentName,\n              entry\n            })\n          }\n        }\n      }\n    }\n  \n    for await (const entry of db.results as PageObjectResponse[]) {\n      if (this._isTopLevelDir(entry)) {\n        const content = await this._getPageContent(entry)\n        const currentDir = this.cms.siteData[this._getBlockName(entry).slug.route] = { ...content }\n        const subPageProp = entry.properties['sub-page'] as PageObjectRelation\n        if (subPageProp.relation.length) {\n          for await (const subPage of subPageProp.relation as PageObjectRelation[]) {\n            const content = await this._getPageContent(subPage)\n            // @ts-ignore This one is annoying - it doesn't like the Route Type even thought it is correct. I am sure I am smarter than the TS compiler.\n            currentDir[content.name.route] = content\n          }\n        }\n      } else {\n        await addSubPage(entry)\n      }\n    }\n    while (pendingEntries.size) {\n      console.log('trigger while', pendingEntries.size)\n      for await (const pendingEntry of pendingEntries) {\n        console.log(pendingEntry.parentName)\n        await addSubPage(pendingEntry.entry)\n        fs.writeFileSync('debug/site-data.json', JSON.stringify(this.cms.siteData))\n      }\n    }\n    console.log('complete')\n    return this.cms\n  }\n\n\n}"],"names":["COVER_IMAGE_REGEX","Object","defineProperty","String","prototype","get","_","kebabCase","this","separator","padStart","length","NotionCMS","cms","cmsId","notionClient","parser","constructor","databaseID","notionAPIKey","metadata","routes","siteData","Client","auth","NotionBlocksHtmlParser","getInstance","isEmpty","console","log","toplevelDirectories","forEach","tld","push","_genRoutes","flat","entries","directory","results","routePart","routeChildren","pickBy","value","key","startsWith","childDirectory","childRes","res","_isTopLevelDir","response","parentPage","properties","relation","_getBlockName","nameProp","name","title","plain_text","async","page","authorProp","Author","authorIds","authors","Promise","all","map","author","users","retrieve","user_id","id","then","_findKey","object","keys","some","k","subPage","pages","page_id","pageContent","blocks","children","list","block_id","page_size","parsed","parse","isFullPage","pageCoverProp","cover","coverImage","external","url","file","match","slug","_getAuthorData","content","URL","db","databases","query","database_id","pendingEntries","Set","addSubPage","entry","parent","parentName","route","updateKey","_getPageContent","pendingEntry","findInPending","delete","shouldAdd","isEqual","add","currentDir","subPageProp","size","fs","writeFileSync","JSON","stringify"],"mappings":"4KAUA,MAAMA,EAAoB,+EAG1BC,OAAOC,eAAeC,OAAOC,UAAW,OAAQ,CAC9CC,IAAK,WACI,OAAAC,EAAEC,UAAUC,KACrB,IAGFP,OAAOC,eAAeC,OAAOC,UAAW,QAAS,CAC/CC,IAAK,SAASI,EAAY,KACxB,OAAOD,KAAKE,SAASF,KAAKG,OAAS,EAAGF,EACxC,IAGF,MAAqBG,EACnBC,IACAC,MACAC,aACAC,OAEAC,YAAYC,EAAoBC,GAC9BX,KAAKK,IAAM,CACTO,SAAU,CAAC,EACXC,OAAQ,GACRC,SAAU,CAAC,GAEbd,KAAKM,MAAQI,EACRV,KAAAO,aAAe,IAAIQ,EAAO,CAC7BC,KAAML,IAEHX,KAAAQ,OAASS,EAAuBC,aACvC,CAEIL,aACEf,EAAEqB,QAAQnB,KAAKK,IAAIS,YACfM,QAAAC,IAAIrB,KAAKsB,qBACbtB,KAAKsB,sBACFtB,KAAAsB,oBAAoBC,SAAeC,IACtCxB,KAAKK,IAAIQ,OAAOY,KAAKzB,KAAK0B,WAAWF,GAAI,IAE3CJ,QAAQC,IAAI,cAAerB,KAAKK,IAAIQ,QACpCb,KAAKK,IAAIQ,OAASb,KAAKK,IAAIQ,OAAOc,QAEtC,CAEIL,0BACF,IAAIxB,EAAEqB,QAAQnB,KAAKK,IAAIS,UACvB,OAAOrB,OAAOmC,QAAQ5B,KAAKK,IAAIS,SACjC,CAEAY,WAAWG,GACT,MAAMC,EAAU,GACVC,EAAYF,EAAU,GACtBG,EAAgBlC,EAAE+B,EAAU,IAAII,QAAO,CAACC,EAAOC,IAAQrC,EAAEsC,WAAWD,EAAK,OAAMP,UAAUM,QAC/F,OAAKF,EAAc7B,QACnB6B,EAAcT,SAA0Bc,IAChC,MAAAC,EAAWtC,KAAK0B,WAAWW,GAC7BC,EAASnC,OACXmC,EAASf,SAAegB,GAAAT,EAAQL,KAAKM,EAAYQ,KAEzCT,EAAAL,KAAKM,EAAYO,EAC3B,IAEFR,EAAQL,KAAKM,GACND,GAV2B,CAACC,EAWrC,CAEAS,eAAgBC,GACR,MAAAC,EAAaD,GAAUE,WAAW,eACjC,OAAA7C,EAAEqB,QAAQuB,EAAWE,SAC9B,CAEAC,cAAcJ,GACN,MAAAK,EAAWL,GAAUE,WAAWI,KAC/B,OAAAD,EAASE,MAAM,IAAIC,UAC5B,CAEAC,qBAAqBC,GACb,MAAAC,EAAaD,EAAKR,YAAYU,OAC9BC,EAAYF,EAAmB,OACjC,IAAAG,EACJ,OAAID,GAAWnD,QACboD,QAAgBC,QAAQC,IACtBH,EAAUI,KAAIR,MAAOS,SAAqC3D,KAAKO,aAAaqD,MAAMC,SAAS,CAAEC,QAASH,EAAOI,QAC7GC,MAAYzB,IACZ,GAAIA,GAAKpC,OACP,OAAOoC,EAAImB,KAAcC,GAAAA,EAAOZ,MAClC,IAEKQ,GAAW,IAEb,EACT,CAEAU,SAASC,EAAgC/B,GACnC,IAAAD,EAWG,OAVPzC,OAAO0E,KAAKD,GAAQE,MAAMC,GACpBA,IAAMlC,GACRD,EAAQgC,EAAOG,IACR,GAELH,EAAOG,IAA2B,iBAAdH,EAAOG,IAC7BnC,EAAQlC,KAAKiE,SAASC,EAAOG,GAA8BlC,QAC1C,IAAVD,QAFT,IAKKA,CACT,CAEAgB,sBAAsBoB,GAChB,IAAAnB,EAEKA,EADuC,SAA3CmB,GAAgCJ,OAC5BI,QAEMtE,KAAKO,aAAagE,MAAMV,SAAS,CAC5CW,QAASF,EAAQP,KAIrB,MAAMU,QAAoBzE,KAAKO,aAAamE,OAAOC,SAASC,KAAK,CAC/DC,SAAUP,EAAQP,GAClBe,UAAW,KAGPC,EAAS/E,KAAKQ,OAAOwE,MAAMP,EAAY3C,SAGzC,GAAAmD,EAAW9B,GAA6B,CAC1C,MAAM+B,EAAiB/B,GAA6BgC,MAChD,IAAAC,EASG,OAPLA,EADEF,GAAiB,aAAcA,EACpBA,GAAeG,UAAUC,IAC7BJ,GAAeK,KACXL,GAAeK,KAAKD,IAErBP,EAAOS,MAAMhG,KAAqB,GAGzC,CACLuD,KAAM/C,KAAK6C,cAAcM,GAA4BsC,KACrDlC,cAAevD,KAAK0F,eAAevC,GACnCiC,aACAO,QAASZ,EAEb,CAAc,MAAA,CACZhC,KAAM,GACNQ,QAAS,GACT6B,WAAY,IAAIQ,IAAI,IACpBD,QAAS,GAEb,CAEAzC,iBACE,MAAM2C,QAAW7F,KAAKO,aAAauF,UAAUC,MAAM,CACjDC,YAAahG,KAAKM,QAGd2F,MAAqBC,IAYrBC,EAAajD,MAAOkD,IAClB,MACAC,EADiBD,EAAMzD,WAAW,eACVC,SAAS,GAEjCF,QAAmB1C,KAAKO,aAAagE,MAAMV,SAAS,CAAEW,QAAS6B,EAAOtC,KACxE,GAAAkB,EAAWvC,GAAa,CAC1B,MAAM4D,EAAatG,KAAK6C,cAAcH,GAAY+C,KAAKc,MACjDC,EAAYxG,KAAKiE,SAASjE,KAAKK,IAAIS,SAAUwF,GAEnD,GAAIE,EAAW,CACb,MAAMb,QAAgB3F,KAAKyG,gBAAgBL,GACtCI,EAAUb,EAAQ5C,KAAKwD,SAAkBC,EAAAb,EAAQ5C,KAAKwD,OAASZ,GAE9D,MAAAH,EAvBU,EAACY,EAA2BH,KAC5C,IAAAT,EAMG,OALPS,EAAe1E,SAAwBmF,IACjCN,IAAUM,EAAaN,QACjBZ,EAAAkB,EACV,IAEKlB,CAAA,EAgBWmB,CAAcP,EAAOH,GAC/BT,GAAOS,EAAeW,OAAOpB,EAAK,KACjC,CACL,IAAIqB,GAAY,EAChB,IAAA,MAAWH,KAAgBT,EACzB,GAAInG,EAAEgH,QAAQV,EAAOM,EAAaN,OAAQ,CAC5BS,GAAA,EAAO,KACrB,CAEEA,GACFZ,EAAec,IAAI,CACjBT,aACAF,SAGN,CACF,GAGe,UAAA,MAAAA,KAASP,EAAG/D,QACvB,GAAA9B,KAAKwC,eAAe4D,GAAQ,CAC9B,MAAMT,QAAgB3F,KAAKyG,gBAAgBL,GACrCY,EAAahH,KAAKK,IAAIS,SAASd,KAAK6C,cAAcuD,GAAOX,KAAKc,OAAS,IAAKZ,GAC5EsB,EAAcb,EAAMzD,WAAW,YACjC,GAAAsE,EAAYrE,SAASzC,OACN,UAAA,MAAAmE,KAAW2C,EAAYrE,SAAkC,CACxE,MAAM+C,QAAgB3F,KAAKyG,gBAAgBnC,GAEhCqB,EAAAA,EAAQ5C,KAAKwD,OAASZ,CACnC,CACF,YAEMQ,EAAWC,GAGrB,KAAOH,EAAeiB,MAAM,CAClB9F,QAAAC,IAAI,gBAAiB4E,EAAeiB,MAC5C,UAAA,MAAiBR,KAAgBT,EACvB7E,QAAAC,IAAIqF,EAAaJ,kBACnBH,EAAWO,EAAaN,OAC9Be,EAAGC,cAAc,uBAAwBC,KAAKC,UAAUtH,KAAKK,IAAIS,UAErE,CAEA,OADAM,QAAQC,IAAI,YACLrB,KAAKK,GACd"}