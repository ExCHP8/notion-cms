{"version":3,"file":"index.js","sources":["../src/notion-cms.ts"],"sourcesContent":["import { Client, isFullPage } from \"@notionhq/client\"\nimport {PageObjectResponse, UserObjectResponse, GetPageResponse} from '@notionhq/client/build/src/api-endpoints'\nimport { NotionBlocksHtmlParser } from '@notion-stuff/blocks-html-parser'\nimport {Blocks} from '@notion-stuff/v4-types'\nimport type { PageEntry, CMS, Page, PageContent, RouteObject,\n   Cover, PageObjectTitle, PageObjectRelation, PageObjectUser, PageMultiSelect} from \"./types\"\nimport _ from 'lodash'\nimport fs from 'fs'\nimport {dirname} from 'path'\n\nfunction writeFile(path: string, contents: string) {\n  fs.mkdirSync(dirname(path), { recursive: true})\n  fs.writeFileSync(path, contents);\n}\n\nconst COVER_IMAGE_REGEX = /<figure notion-figure>[\\s\\S]+<img[^>]*src=['|\"](https?:\\/\\/[^'|\"]+)(?:['|\"])/\n\n\nObject.defineProperty(String.prototype, \"slug\", {\n  get: function() {\n    return _.kebabCase(this)\n  }\n})\n\nObject.defineProperty(String.prototype, \"route\", {\n  get: function(separator = \"/\") {\n    return this.padStart(this.length + 1, separator)\n  }\n})\n\ninterface Options {\n  databaseId: string,\n  notionAPIKey: string,\n  debug?: boolean\n}\n\nexport default class NotionCMS {\n  cms: CMS\n  cmsId: string\n  notionClient: Client\n  parser: NotionBlocksHtmlParser\n  pendingEntries: Set<PageEntry>\n  pageRetrievalCache: Record<string, GetPageResponse>\n  debug: boolean | undefined\n\n  constructor({databaseId, notionAPIKey, debug}: Options = {databaseId : '', notionAPIKey: '', debug: false}) {\n    this.cms = {\n      metadata: {},\n      routes: [],\n      tags: [],\n      tagGroups: {},\n      siteData: {}\n    }\n    this.cmsId = databaseId\n    this.notionClient = new Client({\n      auth: notionAPIKey\n    })\n    this.parser = NotionBlocksHtmlParser.getInstance()\n    this.pendingEntries = new Set<PageEntry>()\n    this.pageRetrievalCache = {}\n    this.debug = debug\n  }\n\n  get data() {\n    if (_.isEmpty(this.cms.siteData)) return\n    return this.cms.siteData\n  }\n\n  get routes() {\n    if (_.isEmpty(this.cms.siteData)) return\n    if (this.toplevelDirectories) {\n      this.cms.routes = []\n      this.toplevelDirectories.forEach(tld => {\n        this.cms.routes.push(this._genRoutes(tld))\n      })\n      return this.cms.routes = this.cms.routes.flat()\n    }\n  }\n\n  get toplevelDirectories() {\n    if (_.isEmpty(this.cms.siteData)) return\n    return Object.entries(this.cms.siteData)\n  }\n\n  _genRoutes(directory: RouteObject): Array<string> {\n    const results = []\n    const routePart = directory[0]\n    const routeChildren = _(directory[1]).pickBy((value, key) => _.startsWith(key, '/')).entries().value()\n    if (!routeChildren.length) return [routePart]\n    routeChildren.forEach(childDirectory => {\n      const childRes = this._genRoutes(childDirectory)\n      if (childRes.length) {\n        childRes.forEach(res => results.push(routePart + res))\n      } else {\n        results.push(routePart + childRes)\n      }\n    })\n    results.push(routePart)\n    return results\n  }\n\n  _clearPageRetrievalCache(): void {\n    this.pageRetrievalCache = {}\n  }\n\n  _isTopLevelDir (response: PageObjectResponse): boolean {\n    const parentPage = response?.properties['parent-page'] as PageObjectRelation \n    return _.isEmpty(parentPage.relation)\n  }\n  \n  _getBlockName(response: PageObjectResponse): string {\n    const nameProp = response?.properties.name as PageObjectTitle \n    return nameProp.title[0]?.plain_text\n  }\n\n  _extractTags(response: PageObjectResponse): Array<string> {\n    const tagProp = response?.properties?.Tags as PageMultiSelect\n    return tagProp.multi_select.map(multiselect => multiselect.name)\n  }\n\n  _assignTagGroup(tag: string, route: string): void {\n    if (!this.cms.tagGroups[tag]) this.cms.tagGroups[tag] = []\n    this.cms.tagGroups[tag].push(route)\n  }\n\n  async _getAuthorData(page: PageObjectResponse): Promise<Array<string>> {\n    const authorProp = page.properties?.Author as PageObjectUser\n    const authorIds = authorProp['people']\n    let authors;\n    if (authorIds?.length) {\n      authors = await Promise.all(\n        authorIds.map(async (author: UserObjectResponse) => await this.notionClient.users.retrieve({ user_id: author.id }))\n      ).then(res => {\n        if (res?.length) {\n          return res.map(author => author.name as string)\n        }\n      })\n      return authors || []\n    }\n    return []\n  }\n\n  _findByKey(object: Record<string, Page>, key: string): Record<string, Page> | undefined {\n    let value;\n    Object.keys(object).some((k: string) => {\n      if (k === key) {\n        value = object[k];\n        return true;\n      }\n      if (object[k] && typeof object[k] === 'object') {\n        value = this._findByKey(object[k] as Record<string, Page>, key);\n        return value !== undefined;\n      }\n    });\n    return value;\n  }\n\n  async _getPageContent(subPage: PageObjectResponse | PageObjectRelation): Promise<PageContent> {\n    let page\n    const tags = [] as Array<string>\n    if ((subPage as PageObjectResponse)?.object === 'page') {\n      page = subPage\n    } else {\n      page = await this._retrievePage(subPage.id)\n    }\n  \n    const pageContent = await this.notionClient.blocks.children.list({\n      block_id: subPage.id,\n      page_size: 50,\n    })\n    const name = this._getBlockName(page as PageObjectResponse).slug\n    const parsed = this.parser.parse(pageContent.results as Blocks)\n\n    // Fall back to the first image in the page if one exists.\n    if (isFullPage(page as PageObjectResponse)) {\n      const pageCoverProp = (page as PageObjectResponse)?.cover as Cover\n      let coverImage;\n      if (pageCoverProp && 'external' in pageCoverProp) {\n        coverImage = pageCoverProp?.external?.url\n      } else if (pageCoverProp?.file){\n        coverImage = pageCoverProp?.file.url \n      } else {\n       coverImage = parsed.match(COVER_IMAGE_REGEX)?.[1]\n      }\n\n      if (isFullPage(page as PageObjectResponse)) {\n        const extractedTags = this._extractTags(page as PageObjectResponse)\n        extractedTags.forEach(tag => {\n          tags.push(tag)\n          if (!_.includes(this.cms.tags, tag)) this.cms.tags.push(tag)\n          this._assignTagGroup(tag, name.route)\n        })\n      }\n      return {\n        name,\n        authors: await this._getAuthorData(page as PageObjectResponse),\n        tags,\n        coverImage,\n        content: parsed\n      }\n    } else return {\n      name: '',\n      authors: [],\n      tags: [],\n      coverImage: new URL(''),\n      content: ''\n    }\n  }\n\n  _findInPending(entry: PageObjectResponse) {\n    let match\n    this.pendingEntries.forEach(pendingEntry => {\n      if (entry === pendingEntry.entry) {\n        match = pendingEntry\n      }\n    })\n    return match\n  }\n\n  async _retrievePage(id: string): Promise<GetPageResponse> {\n    let parentPage = this.pageRetrievalCache[id]\n    // Check cache before making this call.\n    if (!parentPage) {\n      parentPage = await this.notionClient.pages.retrieve({ page_id: id })\n      this.pageRetrievalCache[id] = parentPage\n    }\n    return parentPage\n  }\n\n  async _addPage(entry: PageObjectResponse): Promise<void> {\n    let page, parentName, updateObject;\n    const parentPageProp = entry.properties['parent-page'] as PageObjectRelation\n    const parent = parentPageProp.relation[0]\n\n    if (parent) page = await this._retrievePage(parent.id) \n    if (page && isFullPage(page)) {\n      parentName = this._getBlockName(page).slug.route\n      updateObject = this._findByKey(this.cms.siteData, parentName)\n    } else {\n      updateObject = this.cms.siteData\n    }\n\n    if (updateObject) {\n      const content = await this._getPageContent(entry)\n      if (!updateObject[content.name.route]) updateObject[content.name.route] = content\n      const match = this._findInPending(entry)\n      if (match) this.pendingEntries.delete(match)\n    } else if (parentName) {\n      let shouldAdd = true\n      for (const pendingEntry of this.pendingEntries) {\n        if (_.isEqual(entry, pendingEntry.entry)) {\n          shouldAdd = false; break;\n        };\n      }\n      if (shouldAdd) {\n        this.pendingEntries.add({\n          parentName,\n          entry\n        })\n      }\n    }\n  }\n\n  async fetch(): Promise<CMS> {\n    // For now clear the cache anytime we re-run the fetch. In the future we want to make the cache clearing dynamically based on \n    // an AgencyKit API flag.\n    this._clearPageRetrievalCache()\n    const db = await this.notionClient.databases.query({\n      database_id: this.cmsId,\n    });\n  \n    for await (const entry of db.results as PageObjectResponse[]) {\n      await this._addPage(entry)\n    }\n\n    while (this.pendingEntries.size) {\n      for await (const pendingEntry of this.pendingEntries) {\n        await this._addPage(pendingEntry.entry)\n      }\n    }   \n    void this.routes\n    if (this.debug) writeFile('debug/site-data.json', JSON.stringify(this.cms))\n    return this.cms\n  }\n\n  getTaggedCollection(tags: string | Array<string>): Array<Record<string, Page> | undefined> {\n    if (!_.isArray(tags)) tags = [tags]\n    const taggedPages = []\n    for (const tag of tags) {\n      taggedPages.push(...this.cms.tagGroups[tag])\n    }\n    return _(taggedPages).map(page => this._findByKey(this.cms.siteData, page)).uniq().value()\n  }\n}"],"names":["COVER_IMAGE_REGEX","Object","defineProperty","String","prototype","get","_","kebabCase","this","separator","padStart","length","NotionCMS","cms","cmsId","notionClient","parser","pendingEntries","pageRetrievalCache","debug","constructor","databaseId","notionAPIKey","metadata","routes","tags","tagGroups","siteData","Client","auth","NotionBlocksHtmlParser","getInstance","Set","data","isEmpty","toplevelDirectories","forEach","tld","push","_genRoutes","flat","entries","directory","results","routePart","routeChildren","pickBy","value","key","startsWith","childDirectory","childRes","res","_clearPageRetrievalCache","_isTopLevelDir","response","parentPage","properties","relation","_getBlockName","nameProp","name","title","plain_text","_extractTags","tagProp","Tags","multi_select","map","multiselect","_assignTagGroup","tag","route","async","page","authorProp","Author","authorIds","authors","Promise","all","author","users","retrieve","user_id","id","then","_findByKey","object","keys","some","k","subPage","_retrievePage","pageContent","blocks","children","list","block_id","page_size","slug","parsed","parse","isFullPage","pageCoverProp","cover","coverImage","external","url","file","match","includes","_getAuthorData","content","URL","_findInPending","entry","pendingEntry","pages","page_id","parentName","updateObject","parent","_getPageContent","delete","shouldAdd","isEqual","add","db","databases","query","database_id","_addPage","size","path","contents","JSON","stringify","fs","mkdirSync","dirname","recursive","writeFileSync","getTaggedCollection","isArray","taggedPages","uniq"],"mappings":"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"}