{"version":3,"file":"index.js","sources":["../src/notion-cms.ts"],"sourcesContent":["import { Client, isFullPage } from \"@notionhq/client\"\nimport {PageObjectResponse, UserObjectResponse, GetPageResponse} from '@notionhq/client/build/src/api-endpoints'\nimport { NotionBlocksHtmlParser } from '@notion-stuff/blocks-html-parser'\nimport {Blocks} from '@notion-stuff/v4-types'\nimport type { PageEntry, CMS, PageContent, RouteObject, Cover, PageObjectTitle, PageObjectRelation, PageObjectUser} from \"./types\"\nimport _ from 'lodash'\nimport fs from 'fs'\n\nconst COVER_IMAGE_REGEX = /<figure notion-figure>[\\s\\S]+<img[^>]*src=['|\"](https?:\\/\\/[^'|\"]+)(?:['|\"])/\n\n\nObject.defineProperty(String.prototype, \"slug\", {\n  get: function() {\n    return _.kebabCase(this)\n  }\n})\n\nObject.defineProperty(String.prototype, \"route\", {\n  get: function(separator = \"/\") {\n    return this.padStart(this.length + 1, separator)\n  }\n})\n\ninterface Options {\n  databaseId: string,\n  notionAPIKey: string,\n}\n\nexport default class NotionCMS {\n  cms: CMS\n  cmsId: string\n  notionClient: Client\n  parser: NotionBlocksHtmlParser\n  pendingEntries: Set<PageEntry>\n  pageRetrievalCache: Record<string, GetPageResponse>\n\n  constructor({databaseId, notionAPIKey}: Options = {databaseId : '', notionAPIKey: ''}) {\n    this.cms = {\n      metadata: {},\n      routes: [],\n      tags: [],\n      tagGroups: {},\n      siteData: {}\n    }\n    this.cmsId = databaseId\n    this.notionClient = new Client({\n      auth: notionAPIKey\n    })\n    this.parser = NotionBlocksHtmlParser.getInstance()\n    this.pendingEntries = new Set<PageEntry>()\n    this.pageRetrievalCache = {}\n  }\n\n  get data() {\n    if (_.isEmpty(this.cms.siteData)) return\n    return this.cms.siteData\n  }\n\n  get routes() {\n    if (_.isEmpty(this.cms.siteData)) return\n    if (this.toplevelDirectories) {\n      this.cms.routes = []\n      this.toplevelDirectories.forEach(tld => {\n        this.cms.routes.push(this._genRoutes(tld))\n      })\n      return this.cms.routes = this.cms.routes.flat()\n    }\n  }\n\n  get toplevelDirectories() {\n    if (_.isEmpty(this.cms.siteData)) return\n    return Object.entries(this.cms.siteData)\n  }\n\n  _genRoutes(directory: RouteObject): Array<string> {\n    const results = []\n    const routePart = directory[0]\n    const routeChildren = _(directory[1]).pickBy((value, key) => _.startsWith(key, '/')).entries().value()\n    if (!routeChildren.length) return [routePart]\n    routeChildren.forEach(childDirectory => {\n      const childRes = this._genRoutes(childDirectory)\n      if (childRes.length) {\n        childRes.forEach(res => results.push(routePart + res))\n      } else {\n        results.push(routePart + childRes)\n      }\n    })\n    results.push(routePart)\n    return results\n  }\n\n  _clearPageRetrievalCache(): void {\n    this.pageRetrievalCache = {}\n  }\n\n  _isTopLevelDir (response: PageObjectResponse): boolean {\n    const parentPage = response?.properties['parent-page'] as PageObjectRelation \n    return _.isEmpty(parentPage.relation)\n  }\n  \n  _getBlockName(response: PageObjectResponse): string {\n    const nameProp = response?.properties.name as PageObjectTitle \n    return nameProp.title[0]?.plain_text\n  }\n\n  async _getAuthorData(page: PageObjectResponse): Promise<Array<string>> {\n    const authorProp = page.properties?.Author as PageObjectUser\n    const authorIds = authorProp['people']\n    let authors;\n    if (authorIds?.length) {\n      authors = await Promise.all(\n        authorIds.map(async (author: UserObjectResponse) => await this.notionClient.users.retrieve({ user_id: author.id }))\n      ).then(res => {\n        if (res?.length) {\n          return res.map(author => author.name as string)\n        }\n      })\n      return authors || []\n    }\n    return []\n  }\n\n  _findKey(object: Record<string, object>, key: string): Record<string, object> | undefined {\n    let value;\n    Object.keys(object).some((k: string) => {\n      if (k === key) {\n        value = object[k];\n        return true;\n      }\n      if (object[k] && typeof object[k] === 'object') {\n        value = this._findKey(object[k] as Record<string, object>, key);\n        return value !== undefined;\n      }\n    });\n    return value;\n  }\n\n  async _getPageContent(subPage: PageObjectResponse | PageObjectRelation): Promise<PageContent> {\n    let page;\n    if ((subPage as PageObjectResponse)?.object === 'page') {\n      page = subPage\n    } else {\n      page = await this._retrievePage(subPage.id)\n    }\n  \n    const pageContent = await this.notionClient.blocks.children.list({\n      block_id: subPage.id,\n      page_size: 50,\n    })\n  \n    const parsed = this.parser.parse(pageContent.results as Blocks)\n  \n    // Fall back to the first image in the page if one exists.\n    if (isFullPage(page as PageObjectResponse)) {\n      const pageCoverProp = (page as PageObjectResponse)?.cover as Cover\n      let coverImage;\n      if (pageCoverProp && 'external' in pageCoverProp) {\n        coverImage = pageCoverProp?.external?.url\n      } else if (pageCoverProp?.file){\n        coverImage = pageCoverProp?.file.url \n      } else {\n       coverImage = parsed.match(COVER_IMAGE_REGEX)?.[1]\n      }\n  \n      return {\n        name: this._getBlockName(page as PageObjectResponse).slug,\n        authors: await this._getAuthorData(page as PageObjectResponse),\n        coverImage,\n        content: parsed\n      }\n    } else return {\n      name: '',\n      authors: [],\n      coverImage: new URL(''),\n      content: ''\n    }\n  }\n\n  _findInPending(entry: PageObjectResponse, pendingEntries: Set<PageEntry>) {\n    let match\n    this.pendingEntries.forEach(pendingEntry => {\n      if (entry === pendingEntry.entry) {\n        match = pendingEntry\n      }\n    })\n    return match\n  }\n\n  async _retrievePage(id: string): Promise<GetPageResponse> {\n    let parentPage = this.pageRetrievalCache[id]\n    // Check cache before making this call.\n    if (!parentPage) {\n      parentPage = await this.notionClient.pages.retrieve({ page_id: id })\n      this.pageRetrievalCache[id] = parentPage\n    }\n    return parentPage\n  }\n\n  async _addSubPage(entry: PageObjectResponse): Promise<void> {\n    const parentPageProp = entry.properties['parent-page'] as PageObjectRelation\n    const parent = parentPageProp.relation[0]\n    let parentPage = await this._retrievePage(parent.id)\n\n    if (isFullPage(parentPage)) {\n      const parentName = this._getBlockName(parentPage).slug.route\n      const updateKey = this._findKey(this.cms.siteData, parentName)\n  \n      if (updateKey) {\n        const content = await this._getPageContent(entry)\n        if (!updateKey[content.name.route]) updateKey[content.name.route] = content\n  \n        const match = this._findInPending(entry, this.pendingEntries)\n        if (match) this.pendingEntries.delete(match)\n      } else {\n        let shouldAdd = true\n        for (const pendingEntry of this.pendingEntries) {\n          if (_.isEqual(entry, pendingEntry.entry)) {\n            shouldAdd = false; break;\n          };\n        }\n        if (shouldAdd) {\n          this.pendingEntries.add({\n            parentName,\n            entry\n          })\n        }\n      }\n    }\n  }\n\n  async fetch(): Promise<CMS> {\n    // For now clear the cache anytime we re-run the fetch. In the future we want to make the cache clearing dynamically based on \n    // an AgencyKit API flag.\n    this._clearPageRetrievalCache()\n    const db = await this.notionClient.databases.query({\n      database_id: this.cmsId,\n    });\n  \n    for await (const entry of db.results as PageObjectResponse[]) {\n      if (this._isTopLevelDir(entry)) {\n        const content = await this._getPageContent(entry)\n        const currentDir = this.cms.siteData[this._getBlockName(entry).slug.route] = { ...content }\n        const subPageProp = entry.properties['sub-page'] as PageObjectRelation\n        if (subPageProp.relation.length) {\n          for await (const subPage of subPageProp.relation as PageObjectRelation[]) {\n            const content = await this._getPageContent(subPage)\n            // @ts-ignore This one is annoying - it doesn't like the Route Type even thought it is correct. I am sure I am smarter than the TS compiler.\n            currentDir[content.name.route] = content\n          }\n        }\n      } else {\n        await this._addSubPage(entry)\n      }\n    }\n\n    while (this.pendingEntries.size) {\n      console.log('trigger while', this.pendingEntries.size)\n      for await (const pendingEntry of this.pendingEntries) {\n        console.log(pendingEntry.parentName)\n        await this._addSubPage(pendingEntry.entry)\n        fs.writeFileSync('debug/site-data.json', JSON.stringify(this.cms.siteData))\n      }\n    }\n    console.log('complete')\n    return this.cms\n  }\n}"],"names":["COVER_IMAGE_REGEX","Object","defineProperty","String","prototype","get","_","kebabCase","this","separator","padStart","length","NotionCMS","cms","cmsId","notionClient","parser","pendingEntries","pageRetrievalCache","constructor","databaseId","notionAPIKey","metadata","routes","tags","tagGroups","siteData","Client","auth","NotionBlocksHtmlParser","getInstance","Set","data","isEmpty","toplevelDirectories","forEach","tld","push","_genRoutes","flat","entries","directory","results","routePart","routeChildren","pickBy","value","key","startsWith","childDirectory","childRes","res","_clearPageRetrievalCache","_isTopLevelDir","response","parentPage","properties","relation","_getBlockName","nameProp","name","title","plain_text","async","page","authorProp","Author","authorIds","authors","Promise","all","map","author","users","retrieve","user_id","id","then","_findKey","object","keys","some","k","subPage","_retrievePage","pageContent","blocks","children","list","block_id","page_size","parsed","parse","isFullPage","pageCoverProp","cover","coverImage","external","url","file","match","slug","_getAuthorData","content","URL","_findInPending","entry","pendingEntry","pages","page_id","parent","parentName","route","updateKey","_getPageContent","delete","shouldAdd","isEqual","add","db","databases","query","database_id","currentDir","subPageProp","_addSubPage","size","console","log","fs","writeFileSync","JSON","stringify"],"mappings":"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"}